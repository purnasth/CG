
Digital Differential Analyzer Algorithm (DDA)

DDA is a scan conversion line drawing algorithm based on calculation Δy or Δx using Δy = mΔx equation. We sample the line at unit intervals in one coordinate and find corresponding integer nearest the line path for other coordinate.

Algorithm : 

Step 1: Start the program.
Step 2: Declare the variables x1, y1, x2, y2, dx, dy, x, y.
Step 3: Enter the values of x1, y1, x2, y2.
Step 4: Calculate dx = x2 - x1 and dy = y2 - y1.
Step 5: If |dx| > |dy| then steps = |dx| else steps = |dy|.
Step 6: Calculate xinc = dx / steps and yinc = dy / steps.
Step 7: Set x = x1 and y = y1.
Step 8: Plot pixel (x, y).
Step 9: x = x + xinc and y = y + yinc and set pixels (Round(x), Round(y))
Step 10: Repeat step 9 until x = x2 and y = y2.
Step 11: Stop the program.
<newPage/>
Source Code:

#include <stdio.h>
#include <graphics.h>
#include <conio.h>
int main()
{
    int gd = DETECT, gm, i;
    float x, y, dx, dy, steps;
    int x0, x1, y0, y1;
    initgraph(&gd, &gm, "");
    setbkcolor(WHITE);
    printf("Enter initial points x0 and y0: ");
    scanf("%d%d", &x0, &y0);
    printf("Enter final points x1 and y1: ");
    scanf("%d%d", &x1, &y1);
    dx = (float)(x1 - x0);
    dy = (float)(y1 - y0);
    if (dx >= dy) {
        steps = dx;
    } else {
        steps = dy;
    }
    dx = dx / steps;
    dy = dy / steps;
    x = x0;
    y = y0;
    i = 1;
    while (i <= steps) {
        putpixel(x, y, WHITE);
        x += dx;
        y += dy;
        i = i + 1;
    }
    getch();
    closegraph();
    return 0;
}
<newPage/>

Conclusion:

Hence, we were able to generate a line using DDA algorithm.

Output:

Purna Shrestha

Enter initial points x0 and y0: 100 100
Enter final points x1 and y1: 200 200
<newPage/>

Breseham's Line Drawing Algorithm

Theory:

Bresenham's line algorithm is an algorithm that determines the points of an n-dimensional raster that should be selected in order to form a close approximation to a straight line between two points. It requires less time, less memory and less processing power.

Algorithm:

Step 1: Start the program.
Step 2: Read two points P(x1, y1) and P(x2, y2).
Step 3: Calculate dx = x2 - x1 and dy = y2 - y1.
Step 4: Calculate Decision Parameter(P) 
            P = 2dy - dx.
Step 5: Set initial points x = x1 and y = y1 and i = 0.
Step 6: Plot pixel (x, y).
Step 7: If P < 0 then 
            P = P + 2dy and x = x + 1.
Step 8: Else
            P = P + 2dy - 2dx 
            x = x + 1 and y = y + 1.
Step 9: Repeat step 6 to 8 until x = x2 and y = y2.
Step 10: Stop the program.
<newPage/>
Source Code:

#include <stdio.h>
#include <conio.h>
#include <graphics.h>

int main()
{
    int x, y, x1, y1, x2, y2, p, dx, dy;
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");
    printf("\nEnter the x-coordinate & y-coordinate of the first point: ");
    scanf("%d%d", &x1, &y1);
    printf("\nEnter the x-coordinate & y-coordinate of the second point: ");
    scanf("%d%d", &x2, &y2);
    x = x1;
    y = y1;
    dx = x2 - x1;
    dy = y2 - y1;
    putpixel(x, y, RED);
    p = (2 * dy - dx);
    while (x <= x2)
    {
        if (p < 0) {
            x = x + 1;
            p = p + 2 * dy;
        } else {
            x = x + 1;
            y = y + 1;
            p = p + (2 * dy) - (2 * dx);
        }
        putpixel(x, y, 7);
    }
    getch();
    closegraph();
    return 0;
}
<newPage/>

Conclusion:

Hence, we were able to generate a line using Bresenham's line drawing algorithm.

Output:

Purna Shrestha

Enter the x-coordinate & y-coordinate of the first point: 100 100
Enter the x-coordinate & y-coordinate of the second point: 200 200
<newPage/>

Midpoint Circle Drawing Algorithm

Theory:

Midpoint circle algorithm is an algorithm used to determine the points needed for drawing a circle. It is commonly used in both computer graphics and graphics hardware to draw circles. It is a variant of Bresenham's line algorithm.

Algorithm:

Step 1: Start the program.
Step 2: Input the radius of the circle 'r' & center of a circle (xc, yc).
Step 3: Set the value of x = 0 and y = r such that (x0, y0) = (0, r).
Step 4: Calculate the decision parameter P = 1 - r.
Step 5: At xk position, calculate 
            if P < 0 then 
                P(k+1) = P(k) + 2x(k+1) + 1 
                y(k+1) = yk 
                xk = x(k+1).
            else
                P(k+1) = P(k) + 2x(k+1) + 1 - 2y(k+1) 
                y(k+1) = y(k) - 1 
                x(k+1) = xk.
Step 6: Determine the symmetry points in other octants.
Step 7: Move each calculated pixel position(x, y) to the center (xc, yc) and plot the calculated co-ordinate values x = x + xc and y = y + yc.
Step 8: Repeat step 5 to 7 until x >= y.
Step 9: Stop the program.
<newPage/>

Source Code:

#include <stdio.h>
#include <graphics.h>

void circleMidpoint(int, int, int);
void drawCircle(int, int, int, int);

int main()
{
    int xc, yc, r;

    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");
    printf("Enter center coordinates of circle: ");
    scanf("%d %d", &xc, &yc);
    printf("Enter radius of circle: ");
    scanf("%d", &r);
    circleMidpoint(xc, yc, r);
    getch();
    return 0;
}

void circleMidpoint(int xc, int yc, int r)
{
    int x = 0, y = r;
    int p = 1 - r;

    while (x < y)
    {
        drawCircle(xc, yc, x, y);
        x++;

        if (p < 0)
            p = p + 2 * x + 1;
        else
        {
            y--;
            p = p + 2 * (x - y) + 1;
        }

        drawCircle(xc, yc, x, y);
        delay(50);
    }
}

void drawCircle(int xc, int yc, int x, int y)
{
    putpixel(xc + x, yc + y, WHITE);
    putpixel(xc - x, yc + y, WHITE);
    putpixel(xc + x, yc - y, WHITE);
    putpixel(xc - x, yc - y, WHITE);
    putpixel(xc + y, yc + x, WHITE);
    putpixel(xc - y, yc + x, WHITE);
    putpixel(xc + y, yc - x, WHITE);
    putpixel(xc - y, yc - x, WHITE);
}

Conclusion:

Hence, we were able to generate a circle using Midpoint circle drawing algorithm.

Output:

Purna Shrestha

Enter center coordinates of circle: 200 200
Enter radius of circle: 100
<newPage/>

Implementation of 2D transformation:

Theory:

2D transformation is a process of modifying and repositioning the 2D object. It is used to manipulate the size, shape, and orientation of objects. It is also used to change the coordinate position of an object.

Types of 2D transformation:

- Translation
- Rotation
- Scaling
- Reflection

Algorithm:

Step 1: Start the program.
Step 2: Input point P(xi, yi) the original coordinates.
Step 3: Input the translation distance dx and dy.
Step 4: Calculate the translated coordinates as 
            x = xi + dx 
            y = yi + dy.
Step 5: Plot the translated point P'(xi', yi').
Step 6: Stop the program.

Source Code:

#include <stdio.h>
#include <conio.h>
#include <math.h>
#include <graphics.h>

#define PI acos(-1)
void translate();
void rotate();
void scale();
int main()
{
    int choice;
    while (1)
    {
        printf("Enter your choice:\n");
        printf("1.Translation\n2.Rotation\n3.Scaling\n4.Exit\n");
        scanf("%d", &choice);
        if (choice == 1)
            translate();
        else if (choice == 2)
            rotate();
        else if (choice == 3)
            scale();
        else if (choice == 4)
            break;
        else
            printf("Wrong Choice!! Try again\n");
    }
    return 0;
}
void translate()
{
    int gd = DETECT, gm;
    int x, y, x1, y1, x2, y2, tx, ty;
    printf("****Purna Shrestha****");
    initgraph(&gd, &gm, (char *)"");
    printf("\nEnter first coordinate of the triangle: ");
    scanf("%d %d", &x, &y);
    printf("\nEnter second coordinate of the triangle: ");
    scanf("%d %d", &x1, &y1);
    printf("\nEnter third coordinate of the triangle: ");
    scanf("%d %d", &x2, &y2);
    line(x, y, x1, y1);
    line(x1, y1, x2, y2);
    line(x2, y2, x, y);
    printf("\nEnter the translation vector : ");
    scanf("%d %d", &tx, &ty);

    setcolor(YELLOW);
    line(x + tx, y + ty, x1 + tx, y1 + ty);
    line(x1 + tx, y1 + ty, x2 + tx, y2 + ty);
    line(x2 + tx, y2 + ty, x + tx, y + ty);
    outtext("****Purna Shrestha****");
    delay(10);
    getch();
    closegraph();
}
void rotate()
{
    float x1, y1, x2, y2, x3, y3;
    float s, c, angle;
    int gd = DETECT, gm;
    initgraph(&gd, &gm, (char *)"");
    printf("****Purna Shrestha****");
    printf("\nEnter first coordinate of the triangle: ");
    scanf("%f %f", &x1, &y1);
    printf("\nEnter second coordinate of the triangle: ");
    scanf("%f %f", &x2, &y2);
    printf("\nEnter third coordinate of the triangle: ");
    scanf("%f %f", &x3, &y3);
    line(x1, y1, x2, y2);
    line(x2, y2, x3, y3);
    line(x3, y3, x1, y1);

    printf("Enter rotation angle: ");
    scanf("%f", &angle);
    setcolor(WHITE);
    c = cos(angle * (PI / 180));
    s = sin(angle * (PI / 180));
    x1 = floor(x1 * c + y1 * s);
    y1 = floor(-x1 * s + y1 * c);
    x2 = floor(x2 * c + y2 * s);
    y2 = floor(-x2 * s + y2 * c);
    x3 = floor(x3 * c + y3 * s);
    y3 = floor(-x3 * s + y3 * c);

    setcolor(YELLOW);
    line(x1, y1, x2, y2);
    line(x2, y2, x3, y3);
    line(x3, y3, x1, y1);
    outtext("****Purna Shrestha****");
    getch();
    closegraph();
}
void scale()
{
    int x, y, x1, y1, x2, y2;
    float scalfx, scalfy;
    int gd = DETECT, gm;
    initgraph(&gd, &gm, (char *)"");
    printf("****Purna Shrestha****");
    printf("\nEnter first coordinate of Triangle = ");
    scanf("%d %d", &x, &y);
    printf("\nEnter second coordinate of Triangle = ");
    scanf("%d %d", &x1, &y1);
    printf("\nEnter third coordinate of Triangle = ");
    scanf("%d %d", &x2, &y2);
    line(x, y, x1, y1);
    line(x1, y1, x2, y2);
    line(x2, y2, x, y);
    printf("Enter Scaling factor scalx and scaly : ");
    scanf("%f %f", &scalfx, &scalfy);
    x = x * scalfx;
    x1 = x1 * scalfx;
    x2 = x2 * scalfx;
    y = y * scalfy;
    y1 = y1 * scalfy;
    y2 = y2 * scalfy;
    setcolor(YELLOW);
    line(x, y, x1, y1);
    line(x1, y1, x2, y2);
    line(x2, y2, x, y);
    outtext("****Purna Shrestha****");
    getch();
    closegraph();
}

Conclusion:

Hence, we were able to implement 2D transformation.

Output:

Enter your choice:
1.Translation
2.Rotation
3.Scaling
4.Exit
1
****Purna Shrestha****
Enter first coordinate of the triangle: 100 100
Enter second coordinate of the triangle: 200 200
Enter third coordinate of the triangle: 300 300
Enter the translation vector : 100 100
<newPage/>

